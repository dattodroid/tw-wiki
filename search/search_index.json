{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Thingworx Wiki","text":"<p>Resources directory, Snippets and Best practices.</p>"},{"location":"#changelog","title":"Changelog","text":"<ul> <li>24-Jan-2025 \u2014 Data Ordering <code>new</code></li> <li>17-Jan-2025 \u2014 Azure IoTHub Connector <code>new</code></li> </ul> <p>WIP - mostly dabbling with MkDocs...</p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tag:alwayson","title":"AlwaysOn","text":"<ul> <li>            .NET SDK          </li> <li>            AlwaysOn Connector          </li> <li>            C SDK          </li> <li>            EMS / LSR          </li> <li>            Java SDK          </li> <li>            KEPServer TNI          </li> </ul>"},{"location":"tags/#tag:connector","title":"connector","text":"<ul> <li>            AlwaysOn Connector          </li> <li>            Azure IoTHub Connector          </li> <li>            eMessage Connector          </li> </ul>"},{"location":"tags/#tag:extension","title":"extension","text":"<ul> <li>            Extension SDK          </li> <li>            MQTT          </li> </ul>"},{"location":"tags/#tag:js","title":"js","text":"<ul> <li>            Service Script snippets          </li> </ul>"},{"location":"tags/#tag:snippet","title":"snippet","text":"<ul> <li>            Service Script snippets          </li> </ul>"},{"location":"Connectivity/","title":"Connectivity","text":""},{"location":"Connectivity/#external-resources","title":"External Resources","text":"<ul> <li>Choose a Connectivity Method</li> </ul>"},{"location":"Connectivity/mqtt/","title":"MQTT","text":"","tags":["extension"]},{"location":"Connectivity/AlwaysOn%20Edges/csdk/","title":"C SDK","text":"","tags":["AlwaysOn"]},{"location":"Connectivity/AlwaysOn%20Edges/csdk/#external-resources","title":"External Resources","text":"<ul> <li>PTC Help Center - ThingWorx Edge C SDK</li> <li>PTC Tutorial - C SDK Tutorial</li> <li>PTC Tutorial - Low Level Device Connection (same as above?)</li> </ul>","tags":["AlwaysOn"]},{"location":"Connectivity/AlwaysOn%20Edges/ems/","title":"EMS / LSR","text":"","tags":["AlwaysOn"]},{"location":"Connectivity/AlwaysOn%20Edges/ems/#external-resources","title":"External Resources","text":"<ul> <li>PTC Help Center - ThingWorx Edge MicroServer (EMS) and Lua Script Resource (LSR)</li> <li>PTC Tutorial - Use the Edge MicroServer (EMS) to Connect to ThingWorx</li> <li>PTC Tutorial - Connect Raspberry Pi to ThingWorx</li> </ul>","tags":["AlwaysOn"]},{"location":"Connectivity/AlwaysOn%20Edges/jsdk/","title":"Java SDK","text":"","tags":["AlwaysOn"]},{"location":"Connectivity/AlwaysOn%20Edges/jsdk/#external-resources","title":"External Resources","text":"<ul> <li>PTC Help Center - ThingWorx Edge Java SDK</li> <li>PTC Tutorial - Java SDK Tutorial</li> </ul>","tags":["AlwaysOn"]},{"location":"Connectivity/AlwaysOn%20Edges/kepserver/","title":"KEPServer TNI","text":"","tags":["AlwaysOn"]},{"location":"Connectivity/AlwaysOn%20Edges/nsdk/","title":".NET SDK","text":"","tags":["AlwaysOn"]},{"location":"Connectivity/AlwaysOn%20Edges/nsdk/#external-resources","title":"External Resources","text":"<ul> <li>PTC Help Center - ThingWorx Edge .NET SDK</li> </ul>","tags":["AlwaysOn"]},{"location":"Connectivity/Protocol%20Adapters/azx/","title":"Azure IoTHub Connector","text":"","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#overview","title":"Overview","text":"<p>Protocol adapter for integrating Azure IoT Hub and Azure Blob Storage with Thingworx. The connector's nickname is AZX.</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#key-capabilities","title":"Key Capabilities","text":"<ul> <li>Ingest device-to-cloud (telemetry) data from Azure (Edge) Devices</li> <li>Send cloud-to-device (c2d) data and invoke Direct Methods on Azure (Edge) Devices</li> <li>Manage File Transfers with Azure Blob Storage containers</li> <li>Azure Industrial IoT (IIoT) OPC UA integration (not covered in this document)</li> </ul>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#entities","title":"Entities","text":"<p>See also Class Diagram</p> <ul> <li> <p>The Thingworx Azure IoT Connector is a standalone Java executable. </p> <p>It is exposed on the platform as an <code>AzureIotHubTemplate</code> Thing. That entity holds the connector configurations and handles the interactions with it.</p> </li> <li> <p>An Azure (edge) Device  is defined in Thingworx as an <code>AzureIotThing</code> Thing. It is linked to the <code>AzureIotHubTemplate</code> Thing via the <code>gatewayThing</code> property.</p> <p>Ingress and Egress are exposed as user-defined Remote Properties and Services on the <code>AzureIotThing</code> Things.</p> <p>The routing of IoT Hub messages to and from Thingworx relies on the \"same name\" convention:</p> Platform Azure IotHub Thing name = <code>deviceId</code> Remote Property name (Ingress) = Device-to-cloud (telemetry) message data name Remote Property name (Egress) = Cloud-to-device (c2d) message data name Remote Service name (Egress) = Direct method name <p>For IoT Edge Devices, the remote services or properties must be defined using the format: <code>moduleID</code>::<code>methodName</code> or<code>moduleID</code>::<code>propertyName</code>.</p> </li> <li> <p>An Azure Storage Account is exposed in Thingworx as an <code>AzureBlobStorageTemplate</code> Thing. It is possible to register up to 2 Azure Storage Accounts. One (required) is used internally by the connector as a checkpoint store (eventProcessorHostBlobThing), and one (optional) for File storage (fileRepositoryBlobThing). It is not recommended to use the same Storage Account for both use cases.</p> <p>A blob storage container used for File storage is defined in Thingworx as <code>AzureStorageContainerFileRepository</code> Things. It implements <code>FileRepository</code> and behave as such.</p> </li> <li> <p>The <code>ConnectionServicesHub</code> Thing holds helper services, primarily for device provisioning and job activities.</p> </li> </ul>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#features","title":"Features","text":"","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#device-provisioning","title":"Device Provisioning","text":"<p>The <code>ConnectionServicesHub</code> holds services and events related to device provisioning and lifecycle.</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#services","title":"Services","text":"<ul> <li><code>CreateAzureIotDevice</code> \u2014 Registers a new device in your Azure IoT Hub</li> <li><code>DeleteAzureIotDevice</code> \u2014 Removes the specified device from your Azure IoT Hub</li> <li><code>ImportAzureIotDevices</code> \u2014 Imports devices from an Azure IoT Hub into the platform as Things. The <code>AzureThingImportStatusEvent</code> is fired from the <code>ConnectionServicesHub</code> when the import has completed.</li> </ul>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#events","title":"Events","text":"<ul> <li><code>AzureThingLifecycleEvent</code> \u2014 This event is fired after a lifecycle event occurs on a device in Azure IoT Hub. The event fields are:<ul> <li><code>deviceId</code>: Azure IoT device identifier</li> <li><code>status</code>: Lifecycle status, such as deleteDeviceIdentity or createDeviceIdentity</li> <li><code>twin</code>: Value of the device twin at the time of creation or deletion. The Azure IoT Hub must be configured to route the Device Lifecycle Events to the endpoint consumed by the Connector (generally be enabled by default).</li> </ul> </li> </ul>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#ingress","title":"Ingress","text":"<p>Device-to-cloud (telemetry) messages are exposed on the <code>AzureIotThing</code> Thing as Remote Properties.</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#examples-1","title":"Examples 1","text":"<p><pre><code>{\"messageId\":0,\"deviceId\":\"Devkit playground\",\"temperature\":\"24.39\",\"humidity\":\"77.84\"}\n</code></pre> The temperature reading can be exposed as a remote property named <code>temperature</code> of type NUMBER.</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#examples-2","title":"Examples 2","text":"<p><pre><code>{\"messageId\":0,\"deviceId\":\"Devkit playground\",\"payload\": {\"temperature\":\"24.39\",\"humidity\":\"77.84\"}}\n</code></pre> The temperature reading is nested and cannot directly be mapped to a Thingworx property. The payload can be exposed as a remote property named <code>payload</code> of type JSON. The temperature can subsequently be extracted from the payload property, for example from a DataChange subscription.</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#egress","title":"Egress","text":"","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#cloud-to-device-message","title":"Cloud-to-device message","text":"<p>cloud-to-device (c2d) messages are exposed on the <code>AzureIotThing</code> Thing as Remote Properties.</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#direct-method","title":"Direct Method","text":"<p>Direct Methods (Device Methods) are exposed on the <code>AzureIotThing</code> Thing as Remote Services.</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#file-transfers","title":"File Transfers","text":"<p>An Azure Blob Storage Container exposed in Thingworx as <code>AzureStorageContainerFileRepository</code> behaves like a normal (remote) FileRepository.</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#device-jobs","title":"Device jobs","text":"","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#quick-setup-windows","title":"Quick Setup (Windows)","text":"<p>For testing only</p> <ol> <li>Pre-requisites<ul> <li>an Azure IoTHub</li> <li>an Azure Storage Account with specific requirements:<ul> <li>Firewall is not supported </li> <li>Hierarchical namespace, Blob soft delete, Versioning must be disabled on the Storage used for checkpointing  </li> </ul> </li> <li>a Thingworx platform</li> </ul> </li> <li>Download and extract the ThingWorx Azure IoT Hub Connector archive from eSupport portal</li> <li>On the platform:<ul> <li>Create an <code>Administrator</code> appKey</li> <li>Import the 2 extensions from <code>&lt;AZX&gt;\\extensions</code> (ConnectionService first)</li> <li>Create a Thing that implements the <code>AzureBlobStorageTemplate</code> Template and configure it for your Azure Storage Account</li> <li>Create a Thing that implements the <code>AzureIotHubTemplate</code> Template and configure it for your Azure IoTHub</li> </ul> </li> <li>On the connector:<ul> <li>Edit <code>&lt;AZX&gt;\\connector\\bin\\azure-iot.bat</code> and add the following line after <code>set DEFAULT_JVM_OPTS=...</code>: <pre><code>set AZURE_IOT_OPTS=-Dconfig.file=%APP_HOME%\\conf\\azure-iot.conf -Dlogback.configurationFile=%APP_HOME%\\conf\\logback.xml -Dconfig.plaintext=true\n</code></pre></li> <li>Edit <code>&lt;AZX&gt;\\connector\\conf\\azure-iot.conf</code> and update the following settings:<ul> <li><code>cx-server.transport.websockets.app-key</code>: the appKey </li> <li><code>cx-server.transport.websockets.platforms</code>: the Thingworx WS endpoint URL</li> <li><code>cx-server.protocol.hub-thing-name</code>: the name of the <code>AzureIotHubTemplate</code> Thing created previously</li> </ul> </li> <li>Start the Connector with <code>&lt;AZX&gt;\\connector\\bin\\azure-iot.bat</code></li> </ul> </li> <li>Testing:<ul> <li>Use the MXChip IoT DevKit Simulator &gt; Get Started as Azure Device</li> <li>From the Azure portal, create an Azure Device named MXCHIP_SIM   (or use the <code>CreateAzureIotDevice</code> service on <code>ConnectionServicesHub</code> from Thingworx)<ul> <li>Get the device connection string from the Azure portal and set it on the simulator</li> <li>Run the Simulator. The simulator telemetry messages have the following format:     <pre><code>{\"messageId\":0,\"deviceId\":\"Devkit playground\",\"temperature\":\"23.72\",\"humidity\":\"71.35\"}\n</code></pre></li> </ul> </li> <li>From Composer, create an <code>AzureIotThing</code> Thing named MXCHIP_SIM (or use the <code>ImportAzureIotDevices</code> service on  <code>ConnectionServicesHub</code>)<ul> <li>Update the <code>gatewayThing</code> property to reference the <code>AzureIotHubTemplate</code> Thing</li> <li>Create remote properties named <code>temperature</code> and <code>humidity</code> with type NUMBER</li> </ul> </li> <li>Verify that the temperature and humidity readings are updated on the MXCHIP_SIM Thing</li> </ul> </li> </ol> <p>See also Azure MXChip Development Kit Learning Path</p>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#troubleshooting","title":"Troubleshooting","text":"","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#class-diagram","title":"Class Diagram","text":"<pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n  AzureBlobStorageTemplate .. AzureStorageContainerFileRepository:fileRepositoryBlobThing@AzureIotHubTemplate\n  AzureIotHubAdapterServices &lt;|-- ConnectionServicesHub\n  AzureIotThing &lt;|-- myAzureDevice\n  AzureIotHubTemplate &lt;|-- myAzureIotHub\n  AzureStorageContainerFileRepository &lt;|-- myAzureFileRepository\n  AzureIotHubTemplate &lt;-- AzureIotThing:gatewayThing\n  myAzureIotHub &lt;-- myAzureDevice:gatewayThing\n  AzureBlobStorageTemplate &lt;-- AzureIotHubTemplate:fileRepositoryBlobThing\n  AzureBlobStorageTemplate &lt;-- AzureIotHubTemplate:eventProcessorHostBlobThing\n  style myAzureIotHub fill:#ffffc5\n  style myAzureDevice fill:#ffffc5\n  style myAzureFileRepository fill:#ffffc5\n  classDef thing fill:#ffffc5\n  class AzureIotHubTemplate{\n    &lt;&lt;Template&gt;&gt;\n    Azure IoTHub configs : Configuration\n  }\n  class myAzureIotHub:::thing{\n    &lt;&lt;Thing&gt;&gt;\n  }\n  class AzureIotHubAdapterServices{\n    &lt;&lt;Shape&gt;&gt;\n    CreateAzureIotDevice()\n    DeleteAzureIotDevice()\n    DescribeAzureIotDevice()\n    ImportAzureIotDevices()\n  }\n  class ConnectionServicesHub{\n    &lt;&lt;Thing&gt;&gt;\n  }\n  class AzureIotThing{\n    &lt;&lt;Template::RemoteThing&gt;&gt;\n    twinDesired : JSON\n    twinReported : JSON\n    twinTags : JSON\n  }\n  class myAzureDevice:::thing{\n    &lt;&lt;Thing&gt;&gt;\n    myTelemetryData : RemoteProperty\n    myc2dData : RemoteProperty\n    myDeviceMethod() : RemoteService \n  }\n  class AzureBlobStorageTemplate{\n    &lt;&lt;Template&gt;&gt;\n    accountName : Configuration\n    connectionString : Configuration\n  }\n  class AzureStorageContainerFileRepository{\n    &lt;&lt;Template::FileRepository&gt;&gt;\n    containerName : Configuration\n  }\n  class myAzureFileRepository:::thing{\n    &lt;&lt;Thing&gt;&gt;\n  }</code></pre>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/azx/#external-resources","title":"External Resources","text":"<ul> <li>PTC Help Center - ThingWorx Azure IoT Hub Connector</li> <li>PTC Tutorial - Connect the Azure MXChip Development Kit to Thingworx</li> <li>PTC Tutorial - Connect Azure IoT Devices</li> <li>PTC Tutorial - Azure Connector 4 (Setup)</li> </ul>","tags":["connector"]},{"location":"Connectivity/Protocol%20Adapters/cxs/","title":"AlwaysOn Connector","text":"","tags":["AlwaysOn","connector"]},{"location":"Connectivity/Protocol%20Adapters/emx/","title":"eMessage Connector","text":"","tags":["connector"]},{"location":"Connectivity/REST/","title":"REST","text":""},{"location":"Connectivity/REST/#external-resources","title":"External Resources","text":"<ul> <li>PTC Tutorial - Use REST API to Access ThingWorx</li> <li>PTC Tutorial - REST API Overview and Examples</li> <li>PTC Tutorial - Connect an Arduino Developer Board</li> </ul>"},{"location":"Connectivity/REST/swagger/","title":"Swagger UI","text":"<p>Warn</p> <p>Copilot generated just to test the swagger-ui plugin</p> <p></p>"},{"location":"Platform/dataordering/","title":"Data Ordering","text":"<p>To ensure high throughput, Thingworx heavily relies on parallel and distributed processing. However, high concurrency can lead to requests and events being processed out of order relative to their emission time.</p> <ul> <li>Starting with Thingworx 9.5, it is possible to configure Subscriptions to execute sequentially. This ensures that subscriptions are executed in the order events are triggered.</li> <li>Since 9.7, it is possible to configure Thingworx to ensure that Property writes (i.e. data pushed from devices) are processed in order.</li> <li>Data Ordering refers to the combination of the above features to ensure that data is ingested and data change events are executed in order.</li> </ul> <p>Info</p> <p>The use of Data Ordering can impact processing performance</p>"},{"location":"Platform/dataordering/#sequential-subscriptions-95","title":"Sequential Subscriptions (9.5+)","text":"<ul> <li>Configurable at Subscription level<ul> <li>Driven by the Execute Events Sequentially option on the Subscription</li> </ul> </li> </ul>"},{"location":"Platform/dataordering/#ordered-property-writes-97","title":"Ordered Property Writes (9.7+)","text":"<ul> <li>Applies to data pushed from AlwaysOn devices and Axeda agents using the <code>UpdateSubscribedPropertyValues</code>\u00a0and \u00a0<code>UpdateSubscribedPropertyValuesBatched</code> services<ul> <li>CSDK - <code>twApi_PushSubscribedProperties()</code></li> <li>NSDK/JSDK - <code>VirtualThing::updateSubscribedProperties()</code></li> <li>EMS/LSR - <code>thingworx.server.setProperties()</code></li> <li>Axeda - Data item</li> </ul> </li> <li> <p>System wide configuration to be applied on multiple Thingworx components</p> <ul> <li> <p>Platform</p> <p>In <code>platform-settings.json</code>: <pre><code>{  \n\"PlatformSettingsConfig\": {  \n    \"BasicSettings\": {  \n    \u2026  \n    \"EnableDataOrdering\": true,\n</code></pre></p> </li> <li> <p>Connection Server (9.3+) / eMessage Connector (2.5+)</p> <ul> <li>In connector.conf add <code>cx-server.data-ordering true</code></li> <li>It is recommended to configure the Load Balancer in front of multiple connectors to use device/ip stickiness (for both CXS and EMC)</li> </ul> </li> </ul> </li> </ul>"},{"location":"Platform/dataordering/#external-resources","title":"External Resources","text":"<ul> <li>PTC Help Center - Data Ordering</li> </ul>"},{"location":"Platform/extensionsdk/","title":"Extension SDK","text":"","tags":["extension"]},{"location":"Platform/extensionsdk/#external-resources","title":"External Resources","text":"<ul> <li>PTC Help - ThingWorx Extension Development Guide</li> </ul>","tags":["extension"]},{"location":"Platform/extensionsdk/#java-extensions","title":"Java Extensions","text":"<ul> <li>PTC Tutorial - Create an (Java) Extension</li> <li>PTC Tutorial - Create an Authentication Extension</li> <li>PTC JavaDoc - ThingWorx Platform Java API</li> <li>PTC Article - Common ThingWorx Extension Java SDK Actions</li> </ul>","tags":["extension"]},{"location":"Platform/extensionsdk/#custom-widgets","title":"Custom Widgets","text":"<ul> <li>PTC Help Center - (legacy) Creating Customized ThingWorx Widgets</li> <li>PTC Tutorial - (legacy) Create a Mashup Widget Extension</li> <li>PTC Help Center - (Visual SDK) Packaging a Web Component as a ThingWorx Widget</li> </ul>","tags":["extension"]},{"location":"Platform/filetransfer/","title":"File Transfer","text":""},{"location":"Platform/filetransfer/#external-resources","title":"External Resources","text":"<ul> <li>PTC Help Center - File Transfers</li> <li>PTC Help Center - Edge-Controlled File Transfers</li> <li>PTC Help Center - Always-on File Transfers</li> </ul>"},{"location":"Platform/filetransfer/#upload-file-from-edge-flow","title":"Upload File from Edge flow","text":"<p>Warning</p> <p>Created by reverse engineering logs. Not a source of trust.</p>"},{"location":"Platform/filetransfer/#edge-controlled-axeda-devices","title":"Edge-Controlled (Axeda devices)","text":"<p>The file transfers are managed by the edge device (typically Axeda devices via eMessage connector).</p> <p>All Edge-controlled file transfer activities are initiated by the edge and executed by WSExecutionProcessor threads on the platform.</p>"},{"location":"Platform/filetransfer/#95-with-bind-egress-happy-path","title":"9.5 with bind egress (happy path)","text":"<pre><code>sequenceDiagram\n    box Edge\n    participant Axeda as Axeda device\n    end\n    box Connector\n    participant EMC as eMessage\n    end\n    box Platform\n    participant Thing as AxedaThing\n    participant FTSS as FileTransferSubsystem\n    participant repo as Repository\n    participant ftjob as TransferJob\n    participant resa as Reservation\n    end\n\n    Axeda-&gt;&gt;+EMC: &lt;Ur&gt; Upload Request\n        EMC-&gt;&gt;+FTSS: Copy() async / queuable\n            FTSS--)ftjob: enqueue ft job\n            Note right of ftjob: &lt;  Max File Transfers Allowed in Offline Queue  &lt;br/&gt; &lt;  Max File Transfers Allowed in Offline Queue Per Thing\n            Note over ftjob: PENDING\n            Note over ftjob: Offline queue\n        FTSS--&gt;&gt;-EMC: \n    EMC--&gt;&gt;-Axeda: ok\n\n    Axeda-&gt;&gt;+EMC: /lwPing Ping (or other)\n        EMC-&gt;&gt;+Thing: DequeueEgress()\n            Thing-&gt;&gt;+FTSS: dequeueTransferJobs()\n                FTSS--)resa: check if reservation available\n                Note right of resa: &lt; Total Max Edge-Controlled File Transfers Allowed &lt;br/&gt; &lt; Total Max Edge-Controlled File Transfers Allowed Per Thing\n                FTSS--)resa: create reservation\n                FTSS--)ftjob: dequeue ft job and assign reservation\n                Note over ftjob: Online queue\n                FTSS-&gt;&gt;+ftjob: start ft job\n                    Note over ftjob: ACTIVE\n                    ftjob-&gt;&gt;EMC: StartFileTransfer()\n                ftjob--&gt;&gt;-FTSS: \n            FTSS--&gt;&gt;-Thing: \n        Thing--&gt;&gt;-EMC: \n        EMC-&gt;&gt;FTSS: GetActiveTransferJob()\n    EMC--&gt;&gt;-Axeda: FT jobs detail\n\n    Axeda-&gt;&gt;+EMC: &lt;Ps&gt; Job QUEUED\n    EMC--&gt;&gt;-Axeda: \n\n    Axeda-&gt;&gt;+EMC: &lt;Ps&gt; Job STARTED\n    EMC-&gt;&gt;FTSS: GetActiveTransferJob()\n    EMC-&gt;&gt;FTSS: UpdateTransferStatus() &gt; state=ACTIVE\n    EMC--&gt;&gt;-Axeda: \n\n    loop\n    Axeda-&gt;&gt;+EMC: /upload File Upload\n    EMC-&gt;&gt;FTSS: GetConfigurationTable()\n    EMC-&gt;&gt;FTSS: IsTransferJobActive()\n    EMC-&gt;&gt;FTSS: TouchTransferJob()\n    alt First chunk\n        EMC-&gt;&gt;repo: CreateBinaryFile()\n    else\n        EMC-&gt;&gt;repo: WriteToBinaryFile()\n    end\n    EMC-&gt;&gt;FTSS: UpdateTransferStatus() &gt; Byte written, ...\n    EMC--&gt;&gt;-Axeda: \n    end\n\n    Axeda-&gt;&gt;+EMC: &lt;Ps&gt; Job SUCCESS\n        EMC-&gt;&gt;FTSS: GetActiveTransferJob() \n        EMC-&gt;&gt;+FTSS: UpdateTransferStatus() &gt; state=VALIDATED\n            FTSS-&gt;&gt;+FTSS: completeTransferJob()\n                FTSS-&gt;&gt;ftjob: complete ft job\n                Note over ftjob: VALIDATED\n                FTSS--xresa: return reservation\n                FTSS--xftjob: remove ft job\n            FTSS-&gt;&gt;-FTSS: compare checksum\n        FTSS--&gt;&gt;-EMC: \n    EMC--&gt;&gt;-Axeda: </code></pre>"},{"location":"Platform/filetransfer/#961-with-bindless-egress-happy-path","title":"9.6.1 with bindless egress (happy path)","text":"<pre><code>sequenceDiagram\n    box Edge\n    participant Axeda as Axeda device\n    end\n    box Connector\n    participant EMC as eMessage\n    end\n    box Platform\n    participant Thing as AxedaThing\n    participant FTSS as FileTransferSubsystem\n    participant repo as Repository\n    participant ftjob as TransferJob\n    participant resa as Reservation\n    end\n\n    Axeda-&gt;&gt;+EMC: &lt;Ur&gt; Upload Request\n        EMC-&gt;&gt;+FTSS: Copy() async / queuable\n            FTSS--)ftjob: enqueue ft job\n            Note right of ftjob: &lt;  Max File Transfers Allowed in Offline Queue  &lt;br/&gt; &lt;  Max File Transfers Allowed in Offline Queue Per Thing\n            Note over ftjob: PENDING\n            Note over ftjob: Offline queue\n        FTSS--&gt;&gt;-EMC: \n    EMC--&gt;&gt;-Axeda: ok\n\n    Axeda-&gt;&gt;+EMC: /lwPing Ping (or other)\n        EMC-&gt;&gt;+Thing: DequeueAndGetEgress()\n            Thing-&gt;&gt;+FTSS: dequeueTransferJobs()\n                FTSS--)resa: check if reservation available\n                Note right of resa: &lt; Total Max Edge-Controlled File Transfers Allowed &lt;br/&gt; &lt; Total Max Edge-Controlled File Transfers Allowed Per Thing\n                FTSS--)resa: create reservation\n                FTSS--)ftjob: dequeue ft job and assign reservation\n                Note over ftjob: Online queue\n                FTSS-&gt;&gt;+ftjob: start FileTransferTask\n                Note over ftjob: ACTIVE\n                ftjob--&gt;&gt;-FTSS: \n            FTSS--&gt;&gt;-Thing: \n        Thing--&gt;&gt;-EMC: \n        EMC-&gt;&gt;FTSS: AcknowledgeDelivery()\n    EMC--&gt;&gt;-Axeda: FT jobs detail\n\n    Axeda-&gt;&gt;+EMC: &lt;Ps&gt; Job QUEUED\n    EMC--&gt;&gt;-Axeda: \n\n    Axeda-&gt;&gt;+EMC: &lt;Ps&gt; Job STARTED\n    EMC-&gt;&gt;FTSS: GetActiveTransferJob()\n    EMC-&gt;&gt;FTSS: UpdateTransferStatus() &gt; state=ACTIVE\n    EMC--&gt;&gt;-Axeda: \n\n    loop\n    Axeda-&gt;&gt;+EMC: /upload File Upload\n    EMC-&gt;&gt;FTSS: GetConfigurationTable()\n    EMC-&gt;&gt;+FTSS: PerformChunkUpload()\n        alt First chunk\n            FTSS-&gt;&gt;repo: CreateBinaryFile()\n        else\n            FTSS-&gt;&gt;repo: WriteToBinaryFile()\n        end\n        FTSS-&gt;&gt;ftjob: update ft job \n    FTSS--&gt;&gt;-EMC: \n    EMC-&gt;&gt;FTSS: GetActiveTransferJob()\n    EMC-&gt;&gt;FTSS: UpdateTransferStatus() &gt; Byte written, ...\n    EMC--&gt;&gt;-Axeda: \n    end\n\n    Axeda-&gt;&gt;+EMC: &lt;Ps&gt; Job SUCCESS\n        EMC-&gt;&gt;FTSS: GetActiveTransferJob() \n        EMC-&gt;&gt;+FTSS: UpdateTransferStatus() &gt; state=VALIDATED\n            FTSS-&gt;&gt;+FTSS: completeTransferJob()\n                FTSS-&gt;&gt;ftjob: complete ft job\n                Note over ftjob: VALIDATED\n                FTSS--xresa: return reservation\n                FTSS--xftjob: remove ft job\n            FTSS-&gt;&gt;-FTSS: compare checksum\n        FTSS--&gt;&gt;-EMC: \n    EMC--&gt;&gt;-Axeda: </code></pre>"},{"location":"Platform/filetransfer/#platform-controlled-alwayson-devices","title":"Platform-Controlled (AlwaysOn devices)","text":"<p>All steps in this file transfer are controlled by the Platform.</p>"},{"location":"Platform/peristence/","title":"Persistence / Database","text":""},{"location":"Platform/peristence/#postgresql","title":"PostgreSQL","text":""},{"location":"Platform/peristence/#sql-server-msql","title":"SQL Server (MSQL)","text":""},{"location":"Platform/peristence/#influx","title":"Influx","text":""},{"location":"Platform/peristence/#external-database","title":"External Database","text":""},{"location":"Platform/snippet/","title":"Service Script snippets","text":"","tags":["snippet","js"]},{"location":"Platform/snippet/#external-resources","title":"External Resources","text":"<ul> <li>Unofficial- ThingWorx Snippet Enhanced Documentation</li> </ul>","tags":["snippet","js"]},{"location":"Platform/snippet/#create-an-infotable-from-json","title":"Create an InfoTable from JSON","text":"<pre><code>let my_it_json = {\n    dataShape: {\n        fieldDefinitions: {\n            'name': {\n                name: 'name',\n                baseType: 'STRING',\n                ordinal: 0\n            },\n            'description': {\n                name: 'description',\n                baseType: 'STRING',\n                ordinal: 1\n            },\n        }\n    },\n    rows: []\n};\n\nlet my_it = Resources[\"InfoTableFunctions\"].FromJSON({\n    json: it_json\n});\n</code></pre>","tags":["snippet","js"]}]}